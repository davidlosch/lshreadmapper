% Ausblick.tex
\chapter{Fazit}
\label{sec:fazit}

Zum Abschluss stellen wir unseren aktuellen Stand der Projektarbeit vor und verweisen auf Arbeiten, die für das zweite Semester noch vorgesehen sind. Nachdem wir uns zu Beginn der Projektgruppe mit vielen bestehenden Readmappern auseinander gesetzt hatten, haben wir uns doch dafür entschieden einen eigenen Ansatz zu verfolgen. Um Reads sowohl schnell als auch variantensensitiv zu alignieren, haben wir den Readmapping-Prozess in zwei Schritte aufgeteilt und jeweils einen eigenen Algorithmus für diese Schritte entwickelt. Beim Locality-Sensitive-Hashing (siehe Kapitel \ref{sec:lsh}) wird jedem Read ein passender Abschnitt des Referenzgenoms zugeteilt. Für das Alignment der Reads haben wir den bestehenden Algorithmus zum semiglobalen Alignment von Ukkonen auf Genomvarianten erweitert (siehe Kapitel \ref{sec:align}). Beide Algorithmen wurden von uns in C++ implementiert.

Da wir Genomvarianten auch beim LSH-Algorithmus berücksichtigen wollen, haben wir umfangreiche Statistiken zur Verteilung von Varianten im Referenzgenom erstellt. Diese enthalten Aussagen über Art, Dichte und Länge von Varianten und haben einige Designentscheidungen des Algorithmus beeinflusst.

Die beiden Algorithmen benötigen zusätzlich noch einige Vorverarbeitung, um die wir uns ebenfalls zu großen Teilen bereits gekümmert haben. Dazu gehört, dass wir VCF-Dateien einlesen können und die Informationen über die dortigen Varianten für beide Algorithmen aufbereiten. Für den LSH-Algorithmus haben wir ein System zum Speichern und Laden des Hash-Indexes entwickelt. Außerdem haben wir einen ersten rudimentären Prototypen zusammengestellt, der alle Teile unseres Readmappers miteinander verbindet und aus den einzulesenden Dateien Ausgaben auf der Konsole erzeugt. Die Speicherung der Ausgaben im BAM- bzw. SAM-Format ist leider noch nicht möglich. Für den Umgang mit verschiedenen Dateiformaten und Basenkodierungen haben wir uns in die Seqan-Bibliothek eingearbeitet. Leider kann unser Prototyp in der Praxis bisher nur weniger als die Hälfte der gegebenen Reads auch wirklich alignieren. Das liegt daran, dass unsere Implementierung noch nicht das reverse Komplement von Reads berücksichtigt.

Neben der Implementierung arbeiten wir außerdem an einem Poster für die GCB 2014. Auf diesem Poster beschreiben wir unseren Readmapper, sodass wir diesen voraussichtlich im September auf der GCB vorstellen können. Das Konzept des Posters ist fast vollständig ausgearbeitet, es fehlt allerdings noch das genaue Layout und das eigentliche Erstellen der Grafiken.

\paragraph{Ausblick}

Im Fokus des zweiten Semesters vorrangig allem die Vervollständigung unseres Readmappers sowie dessen Evaluierung. Zu Ersterem gehört vor allem, dass der Readmapper eine weiterverwendbare Ausgabe erzeugt und das reverse Komplement für Reads unterstützt. Außerdem soll er möglichst bald über eine Kommandozeile bedienbar sein, die die geforderten Dateiformate einlesen kann und normgerechte Ausgabedateien erzeugt. Wünschenswert wäre eine vollständige GUI für unseren Readmapper, die auch für eine visuelle Ausgabe der Alignments benutzt werden könnte.

Der zweite Aufgabenblock ist die Evaluierung unseres Readmappers bezüglich seiner Laufzeit, seines Speicherbedarfs und seiner Ausgabequalität. Dazu wollen wir einen umfangreichen Benchmark erstellen, der nach Möglichkeit das vollständige Humangenom umfasst und auch die dazugehörigen Varianten einbindet. Der Vergleich zu anderen Readmappern ist hier natürlich besonders interessant, vor allem ob unsere Variantenunterstützung sich in der Mapping-Qualität bemerkbar macht. Im Zuge der Evaluierung (vermutlich aber schon vorher) werden wir unsere Implementierung gründlich analysieren, um den Ressourcenverbrauch zu minimieren.

Falls nach der vollständigen Implementierung und Evaluierung noch genügend Zeit vorhanden ist, werden wir uns mit der Suche neuer Varianten beschäftigen. Dazu müssen wir die Ausgabe unseres Algorithmus analysieren und Stellen im Referenzgenom finden, an denen sich selbst unter Berücksichtigung bekannter Varianten eine Häufung von Fehlern ergibt. Hierzu wäre es hilfreich, wenn wir bis dahin eine GUI implementiert haben, da diese dann dazu verwendet werden könnte, sogenannte \textit{Pile-Ups} zu visualisieren.